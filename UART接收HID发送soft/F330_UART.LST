C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 1   


C51 COMPILER V7.00, COMPILATION OF MODULE F330_UART
OBJECT MODULE PLACED IN F330_UART.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE F330_UART.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include <c8051f330.h>                 // SFR declarations
   6          #include <stdio.h>
   7          #include "mytype.h"
   8          #include "config.h"
   9          
  10          static uint16 idletimeNET=300;//无按键按下超时,5min
  11          static uint16 idletime=0;//无按键按下超时
  12          static uint8  resetflag=0;//重新连接标志
  13          static uint8  poweroffFlag=0;//关机标志
  14          static uint8  bat_val=0;//电池电压
  15          static uint8  adc_flag=0;//电池电压测试标志，10min
  16          static uint16 adc_timeout=0;//电压测试时间
  17          uint8 code batt[16]= {0x27,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x05,0x04,0x17,0x10,0x0C,0x11}; //
             -0~9,bat,min
  18          
  19          #define vcc_on  1
  20          #define vcc_off 0
  21          #define bl_on   0
  22          #define bl_off  1
  23          //-----------------------------------------------------------------------------
  24          // Global CONSTANTS
  25          //-----------------------------------------------------------------------------
  26          
  27          #define SYSTEMCLOCK      6125000           // SYSCLK frequency in Hz
  28          #define BAUDRATE         57600           // Baud rate of UART in bps
  29          
  30          #define TIMER_PRESCALER            48  // Based on Timer CKCON settings
  31          
  32          // There are SYSTEMCLOCK/TIMER_PRESCALER timer ticks per second, so
  33          // SYSCLK/TIMER_PRESCALER/1000 timer ticks per millisecond.
  34          #define TIMER_TICKS_PER_MS  SYSTEMCLOCK/TIMER_PRESCALER/1000
  35          
  36          // Note: TIMER_TICKS_PER_MS should not exceed 255 (0xFF) for the 8-bit timer
  37          
  38          #define AUX1     TIMER_TICKS_PER_MS
  39          #define AUX2     -AUX1
  40          
  41          #define TIMER0_RELOAD_HIGH       AUX2  // Reload value for Timer0 high byte
  42          
  43          //-----------------------------------------------------------------------------
  44          // Function PROTOTYPES
  45          //-----------------------------------------------------------------------------
  46          void ADC0_Init(void);
  47          void SYSCLK_Init (void);
  48          void UART0_Init (void);
  49          void PORT_Init (void);
  50          void Timer0_Init (void);
  51          void KEY_VAL(uint8 tmp);
  52          void delay_ms(uint16 ms);
  53          //-----------------------------------------------------------------------------
  54          // Global Variables
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 2   

  55          //-----------------------------------------------------------------------------
  56          static uint8 tx_buf[12]= {0x0C,0x00,0xA1,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; //HID发送缓冲区
  57          static uint8 tx_count;//发送字节数，实际发送12个字节
  58          uint8 fn_flag;//Fn键按下状态
  59          #define FnDown  0x00
  60          #define FnUp    0x01
  61          
  62          //key
  63          #define LCtrl   0x14
  64          #define LShift  0x12
  65          #define LAlt    0x10
  66          #define LGui    0x07
  67          //#define RCtrl 0x??
  68          #define RShift  0x59
  69          #define RAlt    0x13
  70          //#define RGui  0x??
  71          #define Fn              0x02
  72          //fn_key,用于测试。实际使用时查表
  73          #define Home    0x5E
  74          #define End             0x2F
  75          #define PgUp    0x28
  76          #define PgDown  0x60
  77          #define Esc             0x0E
  78          #define F1              0x16
  79          #define F3              0x26
  80          
  81          //uart缓冲区使用变量
  82          #define UART_BUFFERSIZE 32
  83          uint8 UARTgetBuf[UART_BUFFERSIZE];
  84          uint8 u8Rxindex = 0;
  85          uint8 u8getQunindex = 0;
  86          uint8 u8sendQunindex = 0;
  87          uint8 TxLock =1;
  88          static uint8 Byte;
  89          
  90          //KEY
  91          uint8 code key_code[128]=
  92          {
  93          
  94                  0x00,0x00,0x65,0x00,0x00,0x00,0x00,0xE3,0x29,0x00,0x00,0x00,0x00,0x2B,0x35,0x00,
  95          
  96                  0xE2,0x00,0xE1,0xE6,0xE0,0x14,0x1E,0x00,0x00,0x00,0x1D,0x16,0x04,0x1A,0x1F,0x00,
  97          
  98                  0x00,0x06,0x1B,0x07,0x08,0x21,0x20,0x00,0x52,0x00,0x19,0x09,0x17,0x15,0x22,0x4F,
  99          
 100                  0x00,0x11,0x05,0x0B,0x0A,0x1C,0x23,0x00,0x00,0x00,0x10,0x0D,0x18,0x24,0x25,0x00,
 101          
 102                  0x00,0x36,0x0E,0x0C,0x12,0x27,0x26,0x00,0x00,0x37,0x38,0x0F,0x33,0x13,0x2D,0x00,
 103          
 104                  0x00,0x00,0x34,0x00,0x2F,0x2E,0x00,0x00,0x39,0xE5,0x28,0x30,0x2C,0x31,0x50,0x00,
 105          
 106                  0x51,0x00,0x00,0x00,0x00,0x00,0x4C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 107          
 108                  0x00,0x2A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 109          };
 110          
 111          //Fn_KEY
 112          uint8 code fn_key_code[128]=
 113          {
 114          
 115                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x00,
 116          
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 3   

 117                  0x00,0x00,0x00,0x00,0x00,0x00,0x3A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3B,0x00,
 118          
 119                  0x00,0x00,0x00,0x00,0x00,0x3D,0x3C,0x00,0x4B,0x00,0x00,0x00,0x00,0x00,0x3E,0x4D,
 120          
 121                  0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x41,0x00,
 122          
 123                  0x00,0x00,0x00,0x00,0x00,0x43,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,
 124          
 125                  0x00,0x00,0x00,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x00,
 126          
 127                  0x4E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 128          
 129                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 130          };
 131          
 132          //-----------------------------------------------------------------------------
 133          // MAIN Routine
 134          //-----------------------------------------------------------------------------
 135          
 136          void main (void)
 137          {
 138   1              uint8 i,tmp;
 139   1              PCA0MD &= ~0x40;                    // WDTE = 0 (clear watchdog timer
 140   1              // enable)
 141   1              PORT_Init();                        // Initialize Port I/O
 142   1              SYSCLK_Init ();                     // Initialize Oscillator
 143   1              UART0_Init();
 144   1              Timer0_Init ();                  //1ms定时器
 145   1      
 146   1              vcc_ctrl        =       vcc_on;//打开系统总电源,1开0关
 147   1              bl_conn_ctrl=   0;//根据外部按钮的状态控制蓝牙模块
 148   1              zb_led2         =       0;//1为亮，0为灭，LED2未连接
 149   1              //bl_state      为蓝牙模块状态输入
 150   1              //key_int0  按键中断及开机
 151   1              //zb_adc0   电池电压判断
 152   1              idletime=0;
 153   1              resetflag=0;//重新连接标志
 154   1              poweroffFlag=0;
 155   1              adc_flag=0;
 156   1      
 157   1      
 158   1              //'0c 00 a1 01 00 00 27 00 00 00 00 00
 159   1              tx_buf[0]=0x0C;//固定开头
 160   1              tx_buf[1]=0x00;
 161   1              tx_buf[2]=0xA1;
 162   1              tx_buf[3]=0x01;
 163   1      
 164   1              tx_buf[4]=0x00;//功能键shift、alt、ctrl、win
 165   1              tx_buf[5]=0x00;//固定00
 166   1      
 167   1              tx_buf[6]=0x00;//后面6个字节为按键码
 168   1              tx_buf[7]=0x00;
 169   1              tx_buf[8]=0x00;
 170   1              tx_buf[9]=0x00;
 171   1              tx_buf[10]=0x00;
 172   1              tx_buf[11]=0x00;
 173   1      
 174   1              fn_flag=FnUp;
 175   1      
 176   1              ADC0_Init();
 177   1              bl_vcc_ctrl     =       bl_on;/// /1为关闭蓝牙电源，0为开启
 178   1              EA = 1;
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 4   

 179   1      
 180   1      
 181   1              while(1)
 182   1              {
 183   2                      delay_ms(10);
 184   2      
 185   2                      if((TxLock == 1 )&& (u8Rxindex != 0))
 186   2                      {
 187   3                              TxLock = 0;                 // Set the flag to zero
 188   3      
 189   3                              // If a new word is being output
 190   3                              if ( u8Rxindex == u8getQunindex )
 191   3                              {
 192   4                                      u8sendQunindex = 0;
 193   4                              }
 194   3      
 195   3                              tmp = UARTgetBuf[u8sendQunindex];
 196   3      
 197   3                              KEY_VAL(tmp);  //break;
 198   3      
 199   3                              u8sendQunindex++;            // Update counter
 200   3      
 201   3                              u8Rxindex--;             // Decrease array size
 202   3      
 203   3                              TI0 = 1;                      // Set transmit flag to 1
 204   3      
 205   3                      }
 206   2                      else
 207   2                      {
 208   3                              u8Rxindex = 0;            // Set the array size to 0
 209   3                              TxLock = 1;                    // Indicate transmission complete
 210   3                      }
 211   2      
 212   2                      if(resetflag)
 213   2                      {
 214   3                              idletime=0;//重新连接按下则空闲等待置0，从新计数
 215   3                              resetflag=0;
 216   3      
 217   3                              bl_conn_ctrl=1;//蓝牙清楚记忆，重新连接
 218   3                              delay_ms(2000);
 219   3                              bl_conn_ctrl=0;
 220   3      
 221   3                      }
 222   2      
 223   2                      if(poweroffFlag)
 224   2                      {
 225   3                              poweroffFlag=0;
 226   3                              vcc_ctrl=vcc_off;//总电源关闭
 227   3                      }
 228   2      
 229   2                      if(adc_flag)
 230   2                      {
 231   3                              adc_flag=0;
 232   3                              ADC0_Init();
 233   3                      }
 234   2              }
 235   1      }
*** WARNING C280 IN LINE 138 OF F330_UART.C: 'i': unreferenced local variable
 236          
 237          //-----------------------------------------------------------------------------
 238          // Initialization Subroutines
 239          //-----------------------------------------------------------------------------
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 5   

 240          
 241          //-----------------------------------------------------------------------------
 242          // PORT_Init
 243          //-----------------------------------------------------------------------------
 244          //
 245          // Return Value : None
 246          // Parameters   : None
 247          //
 248          // Configure the Crossbar and GPIO ports.
 249          //
 250          // P0.4   digital   push-pull    UART TX
 251          // P0.5   digital   open-drain   UART RX
 252          //
 253          //-----------------------------------------------------------------------------
 254          void PORT_Init (void)
 255          {
 256   1              P1MDIN    = 0x7F;
 257   1              P0MDOUT   = 0x14;
 258   1              P1MDOUT   = 0x48;
 259   1              XBR0    = 0x01;                     // Enable UART on P0.4(TX) and P0.5(RX)
 260   1              XBR1    = 0x40;                     // Enable crossbar and weak pull-ups
 261   1      }
 262          //ADC Init P1.7-GND
 263          void ADC0_Init()
 264          {
 265   1              uint8 k;
 266   1              uint16 adc_val;
 267   1      
 268   1              EA=0;
 269   1              delay_ms(50);
 270   1      
 271   1      
 272   1              AMX0P     = 0x0F;//P1.7
 273   1              AMX0N     = 0x11;//GND
 274   1              ADC0CF   |= 0x04;//LEFT ADJUST
 275   1              AD0EN     = 1;
 276   1              adc_val   = 0;
 277   1              for(k=0; k<10; k++)
 278   1              {
 279   2                      AD0INT=0;
 280   2                      AD0BUSY=1;//转换ADC
 281   2                      while(!AD0INT);//等待转换完成
 282   2                      if(k>4)adc_val += ADC0H;
 283   2              }
 284   1              AD0EN = 0;
 285   1      
 286   1              k=(uint8)(adc_val / 5)+3;//补偿3-36mv，4-48mv
 287   1      
 288   1              if(k>115)bat_val=100;//2776
 289   1              else if(k>110)bat_val=75;//2655
 290   1              else if(k>105)bat_val=50;//2535
 291   1              else if(k>100)bat_val=40;//2414
 292   1              else if(k>95)bat_val=30;//2293
 293   1              else if(k>90)bat_val=20;//2173
 294   1              else if(k>85)bat_val=10;//2052
 295   1              else if(k>80)bat_val=5;//1931
 296   1              else //if(k>75)//1811
 297   1              {
 298   2                      bat_val=0;
 299   2                      poweroffFlag=1;
 300   2              }
 301   1              EA=1;
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 6   

 302   1      }
 303          //-----------------------------------------------------------------------------
 304          // SYSCLK_Init
 305          //-----------------------------------------------------------------------------
 306          //
 307          // Return Value : None
 308          // Parameters   : None
 309          //
 310          // This routine initializes the system clock to use the internal oscillator
 311          // at its maximum frequency.
 312          // Also enables the Missing Clock Detector.
 313          //-----------------------------------------------------------------------------
 314          
 315          void SYSCLK_Init (void)
 316          {
 317   1      
 318   1              OSCICN    = 0x81;                                       //6.125MHz
 319   1      
 320   1              RSTSRC  = 0x04;                     // Enable missing clock detector
 321   1      
 322   1      }
 323          //1ms定时器
 324          void Timer0_Init (void)
 325          {
 326   1              TH0 =TIMER0_RELOAD_HIGH;
 327   1              CKCON |=  0x02;//48分频
 328   1      
 329   1              TL0 = TH0;                          // init Timer1
 330   1              TMOD &= ~0x0F;                      // TMOD: timer 1 in 8-bit autoreload
 331   1              TMOD |=  0x02;
 332   1              TR0 = 1;
 333   1              ET0=1;
 334   1      }
 335          //-----------------------------------------------------------------------------
 336          // UART0_Init
 337          //-----------------------------------------------------------------------------
 338          //
 339          // Return Value : None
 340          // Parameters   : None
 341          //
 342          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 343          //-----------------------------------------------------------------------------
 344          void UART0_Init (void)
 345          {
 346   1              SCON0 = 0x10;                       // SCON0: 8-bit variable bit rate
 347   1              //        level of STOP bit is ignored
 348   1              //        RX enabled
 349   1              //        ninth bits are zeros
 350   1              //        clear RI0 and TI0 bits
 351   1              if (SYSTEMCLOCK/BAUDRATE/2/256 < 1)
 352   1              {
 353   2                      TH1 = -(SYSTEMCLOCK/BAUDRATE/2);
 354   2                      CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
 355   2                      CKCON |=  0x08;
 356   2              }
 357   1              else if (SYSTEMCLOCK/BAUDRATE/2/256 < 4)
 358   1              {
 359   2                      TH1 = -(SYSTEMCLOCK/BAUDRATE/2/4);
 360   2                      CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
 361   2                      CKCON |=  0x01;
 362   2              }
 363   1              else if (SYSTEMCLOCK/BAUDRATE/2/256 < 12)
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 7   

 364   1              {
 365   2                      TH1 = -(SYSTEMCLOCK/BAUDRATE/2/12);
 366   2                      CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
 367   2              }
 368   1              else
 369   1              {
 370   2                      TH1 = -(SYSTEMCLOCK/BAUDRATE/2/48);
 371   2                      CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
 372   2                      CKCON |=  0x02;
 373   2              }
 374   1      
 375   1              TL1 = TH1;                          // init Timer1
 376   1              TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload
 377   1              TMOD |=  0x20;
 378   1              TR1 = 1;                            // START Timer1
 379   1              TxLock = 1;                       // Flag showing that UART can transmit
 380   1              IP |= 0x10;                         // Make UART high priority
 381   1              ES0 = 1;                            // Enable UART0 interrupts
 382   1      }
 383          
 384          //-----------------------------------------------------------------------------
 385          // Interrupt Service Routines
 386          //-----------------------------------------------------------------------------
 387          //-----------------------------------------------------------------------------
 388          // Timer0_ISR
 389          //-----------------------------------------------------------------------------
 390          void Timer0_ISR (void) interrupt 1
 391          {
 392   1              static int counter = 0;
 393   1      
 394   1              if((counter++) >= 1000)
 395   1              {
 396   2                      counter = 0;
 397   2                      idletime++;
 398   2                      adc_timeout++;
 399   2      
 400   2                      if(idletime>=idletimeNET)//5min
 401   2                      {
 402   3                              idletime=0;
 403   3                              poweroffFlag=1;
 404   3                      }
 405   2                      if(adc_timeout>=600)//10min
 406   2                      {
 407   3                              adc_timeout=0;
 408   3                              adc_flag=1;
 409   3                      }
 410   2              }
 411   1      }
 412          //-----------------------------------------------------------------------------
 413          // UART0_Interrupt
 414          //-----------------------------------------------------------------------------
 415          //
 416          // This routine is invoked whenever a character is entered or displayed on the
 417          // Hyperterminal.
 418          //
 419          //-----------------------------------------------------------------------------
 420          
 421          void UART0_Interrupt (void) interrupt 4
 422          {
 423   1              idletime=0;//有按键接收则，空闲等待时间置0，从新计数
 424   1      
 425   1              if (RI0 == 1)
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 8   

 426   1              {
 427   2                      if( u8Rxindex == 0)
 428   2                      {
 429   3                              // If new word is entered
 430   3                              u8getQunindex = 0;
 431   3                      }
 432   2      
 433   2                      RI0 = 0;                           // Clear interrupt flag
 434   2      
 435   2                      Byte = SBUF0;                      // Read a character from UART
 436   2      
 437   2                      if (u8Rxindex < UART_BUFFERSIZE)
 438   2                      {
 439   3                              UARTgetBuf[u8getQunindex] = Byte; // Store in array
 440   3      
 441   3                              u8Rxindex++;             // Update array's size
 442   3      
 443   3                              u8getQunindex++;             // Update counter
 444   3                      }
 445   2              }
 446   1      
 447   1              if (TI0 == 1)                   // Check if transmit flag is set
 448   1              {
 449   2                      TI0 = 0;                           // Clear interrupt flag
 450   2      
 451   2                      if (tx_count <12)         // 总共发送12个字节
 452   2                      {
 453   3      
 454   3                              // Store a character in the variable byte
 455   3                              SBUF0= tx_buf[tx_count++];
 456   3      
 457   3                      }
 458   2                      else
 459   2                      {
 460   3                              tx_count = 0;            // Set the array size to 0
 461   3                              TxLock = 1;                    // Indicate transmission complete
 462   3                      }
 463   2              }
 464   1      }
 465          
 466          //键值处理
 467          void KEY_VAL(uint8 tmp)
 468          {
 469   1              switch (tmp)
 470   1              {
 471   2              case LCtrl:
 472   2              {
 473   3                      tx_buf[4]|=0x01;
 474   3                      break;
 475   3              }
 476   2              case LShift:
 477   2              {
 478   3                      tx_buf[4]|=0x02;
 479   3                      break;
 480   3              }
 481   2              case LAlt:
 482   2              {
 483   3                      tx_buf[4]|=0x04;
 484   3                      break;
 485   3              }
 486   2              case LGui:
 487   2              {
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 9   

 488   3                      tx_buf[4]|=0x08;
 489   3                      break;
 490   3              }
 491   2              case RShift:
 492   2              {
 493   3                      tx_buf[4]|=0x20;
 494   3                      break;
 495   3              }
 496   2              case RAlt:
 497   2              {
 498   3                      tx_buf[4]|=0x40;
 499   3                      break;
 500   3              }
 501   2              case LCtrl+0x80:
 502   2              {
 503   3                      tx_buf[4]&=~0x01;
 504   3                      break;
 505   3              }
 506   2              case LShift+0x80:
 507   2              {
 508   3                      tx_buf[4]&=~0x02;
 509   3                      break;
 510   3              }
 511   2              case LAlt+0x80:
 512   2              {
 513   3                      tx_buf[4]&=~0x04;
 514   3                      break;
 515   3              }
 516   2              case LGui+0x80:
 517   2              {
 518   3                      tx_buf[4]&=~0x08;
 519   3                      break;
 520   3              }
 521   2              case RShift+0x80:
 522   2              {
 523   3                      tx_buf[4]&=~0x20;
 524   3                      break;
 525   3              }
 526   2              case RAlt+0x80:
 527   2              {
 528   3                      tx_buf[4]&=~0x40;
 529   3                      break;
 530   3              }
 531   2              case Fn:
 532   2              {
 533   3                      fn_flag=FnDown;
 534   3                      tx_buf[6]=0x00;
 535   3                      break;
 536   3              }
 537   2              case Fn+0x80:
 538   2              {
 539   3                      fn_flag=FnUp;
 540   3                      tx_buf[6]=0x00;
 541   3                      tx_buf[7]=0x00;
 542   3                      tx_buf[8]=0x00;
 543   3                      tx_buf[9]=0x00;
 544   3                      tx_buf[10]=0x00;
 545   3                      tx_buf[11]=0x00;
 546   3                      break;
 547   3              }
 548   2              default :
 549   2              {
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 10  

 550   3                      if(tmp & 0x80)
 551   3                      {
 552   4                              tx_buf[6]=0x00;
 553   4                              tx_buf[7]=0x00;
 554   4                              tx_buf[8]=0x00;
 555   4                              tx_buf[9]=0x00;
 556   4                              tx_buf[10]=0x00;
 557   4                              tx_buf[11]=0x00;
 558   4                      }
 559   3                      else
 560   3                      {
 561   4                              if(fn_flag==FnUp)
 562   4                              {
 563   5                                      tx_buf[6]=key_code[tmp];
 564   5                              }
 565   4      
 566   4                              if(fn_flag==FnDown)     //Fn键按下
 567   4                              {
 568   5                                      if(tmp==0x2B)//Fn+F//重新连接
 569   5                                      {
 570   6                                              tx_buf[6]=0x00;
 571   6                                              resetflag=1;//重新连接标志置1
 572   6                                      }
 573   5                                      if(tmp==0x5D)//Fn+A=1c///0x5D(ok)//关机标志
 574   5                                      {
 575   6                                              tx_buf[6]=0x00;
 576   6                                              poweroffFlag=1;//关机标志置1
 577   6                                      }
 578   5                                      if(tmp==0x64)//Fn+S=1b///0x4A/67(BAT)//电池电量
 579   5                                      {
 580   6                                              ADC0_Init();
 581   6                                              tx_buf[6]=batt[bat_val/100];
 582   6                                              tx_buf[7]=batt[bat_val%100/10];
 583   6                                              tx_buf[8]=batt[bat_val%10];
 584   6                                              tx_buf[9]=batt[10];//B
 585   6                                              tx_buf[10]=batt[11];//A
 586   6                                              tx_buf[11]=batt[12];//T
 587   6      
 588   6                                      }
 589   5                                      if(tmp==0x1B)//Fn+S=1b//延长自动关机时间至
 590   5                                      {
 591   6                                              if(idletimeNET<600)
 592   6                                              {
 593   7                                                      idletimeNET=1800;//30min
 594   7      
 595   7                                                      tx_buf[6]=batt[3];
 596   7                                                      tx_buf[7]=batt[0];
 597   7                                              }
 598   6                                              else
 599   6                                              {
 600   7                                                      idletimeNET=300;//5min
 601   7                                                      tx_buf[6]=batt[0];
 602   7                                                      tx_buf[7]=batt[5];
 603   7                                              }
 604   6      
 605   6                                              tx_buf[8]=batt[13];//m
 606   6                                              tx_buf[9]=batt[14];//i
 607   6                                              tx_buf[10]=batt[15];//n
 608   6                                              tx_buf[11]=0x00;
 609   6                                      }
 610   5                                      else
 611   5                                      {
C51 COMPILER V7.00  F330_UART                                                              10/08/2018 22:24:57 PAGE 11  

 612   6                                              tx_buf[6]=fn_key_code[tmp];
 613   6                                      }
 614   5                              }
 615   4                      }
 616   3      
 617   3                      break;
 618   3              }
 619   2              }
 620   1      
 621   1      }
 622          
 623          
 624          /*=================================================================*/
 625          /*
 626                  delay_ms(1);  //n=600,1ms,11.0592MHz
 627                  delay_us(1);  //1us
 628          
 629          */
 630          /******************************delay time**********************************
 631          void delay_us(uint8 us)
 632          {
 633           while(us--);
 634          }                                                                                                                                               */
 635          //**************************
 636          void delay_ms(uint16 ms)
 637          {
 638   1              uint16 n ;
 639   1              while(ms--)
 640   1              {
 641   2                      n  =  500;
 642   2                      while(n--);
 643   2              }
 644   1      }
 645          //-----------------------------------------------------------------------------
 646          // End Of File
 647          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    933    ----
   CONSTANT SIZE    =    272    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     63       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
